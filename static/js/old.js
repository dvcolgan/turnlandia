// Generated by CoffeeScript 1.6.3
var Board, Sector;

Sector = (function() {
  function Sector(board, $domNode, x, y) {
    var firstSquareX, firstSquareY,
      _this = this;
    this.board = board;
    this.$domNode = $domNode;
    this.x = x;
    this.y = y;
    this.squares = {};
    this.$domNode.css('left', (this.x * TB.sectorSize * TB.gridSize - this.board.scroll.x) + 'px').css('top', (this.y * TB.sectorSize * TB.gridSize - this.board.scroll.y) + 'px');
    firstSquareX = this.x * TB.sectorSize;
    firstSquareY = this.y * TB.sectorSize;
    $.getJSON('/api/sector/' + firstSquareX + '/' + firstSquareY + '/' + TB.sectorSize + '/' + TB.sectorSize + '/', function(data, status) {
      var $squareDomNode, action, destIn, i, newSquare, squareData, srcIn, _i, _j, _len, _len1, _ref, _results;
      if (status === 'success') {
        for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
          squareData = data[i];
          $squareDomNode = $('<div class="grid-square">\
                                            <div class="subtile north-west"></div>\
                                            <div class="subtile north-east"></div>\
                                            <div class="subtile south-west"></div>\
                                            <div class="subtile south-east"></div>\
                                        </div>');
          $squareDomNode.css('left', parseInt((i % TB.sectorSize) * TB.gridSize) + 'px').css('top', parseInt(Math.floor(i / TB.sectorSize) * TB.gridSize) + 'px');
          _this.$domNode.append($squareDomNode);
          if (!(squareData.col in _this.squares)) {
            _this.squares[squareData.col] = {};
          }
          if (!(squareData.col in _this.board.squares)) {
            _this.board.squares[squareData.col] = {};
          }
          newSquare = new Square(_this, $squareDomNode, squareData);
          _this.board.squares[squareData.col][squareData.row] = newSquare;
          _this.squares[squareData.col][squareData.row] = newSquare;
        }
        _ref = TB.actions;
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          action = _ref[_j];
          srcIn = _this.containsSquare(action.srcCol, action.srcRow);
          destIn = _this.containsSquare(action.destCol, action.destRow);
          if (srcIn && destIn) {
            _results.push(_this.board.drawArrow(_this.board.squares[action.srcCol][action.srcRow], _this.board.squares[action.destCol][action.destRow]));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else {
        return alert(JSON.stringify(data));
      }
    });
  }

  Sector.prototype.show = function() {};

  Sector.prototype.hide = function() {};

  Sector.prototype.containsSquare = function(col, row) {
    return col >= this.x * TB.sectorSize && row >= this.y * TB.sectorSize && col < this.x * TB.sectorSize + TB.sectorSize && row < this.y * TB.sectorSize + TB.sectorSize;
  };

  return Sector;

})();

Board = (function() {
  function Board($domNode, boardConsts) {
    var _this = this;
    this.$domNode = $domNode;
    _.extend(this, boardConsts);
    this.scroll = {
      x: 0,
      y: 0
    };
    this.maxDepth = 6;
    this.scroll.x = -this.getViewWidth() / 2;
    this.scroll.y = -this.getViewHeight() / 2;
    this.sectors = {};
    this.squares = {};
    this.activeSquare = null;
    this.isMoving = null;
    this.moveStartSquare = null;
    this.$domNode.on('click', '.grid-square', function(event) {
      var $squareDomNode, col, end, graph, node, result, row, skip, squareTraversalCosts, start, totalCost, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
      if (!(Math.abs(_this.lastScroll.x - _this.scroll.x) < 5 && Math.abs(_this.lastScroll.y - _this.scroll.y) < 5)) {
        console.log('ignoring click');
        return;
      }
      console.log(TB.currentAction);
      if (TB.currentAction === 'road') {
        $.ajax({
          url: '/api/action/road/' + 1 + '/' + _this.activeSquare.col + '/' + _this.activeSquare.row + '/',
          method: 'POST',
          dataType: 'json',
          success: function(data) {
            return true;
          }
        });
      } else if (TB.currentAction === 'move') {
        if (!_this.isMoving) {
          _this.moveStartSquare = _this.activeSquare;
          _this.isMoving = true;
          squareTraversalCosts = _this.getSquareTraversalCosts(_this.moveStartSquare.col, _this.moveStartSquare.row, _this.maxDepth);
          $('.reachable-square').removeClass('reachable-square');
          graph = new astar.Graph(squareTraversalCosts);
          for (col = _i = 0, _ref = _this.maxDepth * 2; 0 <= _ref ? _i <= _ref : _i >= _ref; col = 0 <= _ref ? ++_i : --_i) {
            for (row = _j = 0, _ref1 = _this.maxDepth * 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; row = 0 <= _ref1 ? ++_j : --_j) {
              start = graph.nodes[_this.maxDepth][_this.maxDepth];
              end = graph.nodes[col][row];
              console.log('start ' + start.x + ' ' + start.y + ', end ' + end.x + ' ' + end.y);
              result = astar.astar.search(graph.nodes, start, end);
              totalCost = 0;
              skip = false;
              for (_k = 0, _len = result.length; _k < _len; _k++) {
                node = result[_k];
                if (node.cost === 0) {
                  skip = true;
                }
                totalCost += node.cost;
                if (totalCost > _this.maxDepth) {
                  skip = true;
                }
              }
              if (skip) {
                continue;
              }
              for (_l = 0, _len1 = result.length; _l < _len1; _l++) {
                node = result[_l];
                $squareDomNode = _this.squares[(_this.moveStartSquare.col - _this.maxDepth) + col][(_this.moveStartSquare.row - _this.maxDepth) + row].$domNode;
                $squareDomNode.addClass('reachable-square');
              }
            }
          }
        } else {
          console.log('move done');
          _this.isMoving = false;
          $('.reachable-square').removeClass('reachable-square');
          $.ajax({
            url: '/api/action/move/' + _this.moveStartSquare.col + '/' + _this.moveStartSquare.row + '/' + _this.activeSquare.col + '/' + _this.activeSquare.row + '/',
            method: 'POST',
            dataType: 'json',
            success: function(data) {
              return true;
            },
            error: function(data) {
              alert('Problem saving your action.  The page will now refresh.  Sorry, I should make this more robust sometime.');
              return window.location.href += '';
            }
          });
        }
      }
    });
    $(document).keydown(function(event) {
      _this.isMoving = false;
      return true;
    });
    this.$domNode.on('mouseenter', '.grid-square', function(event) {
      var $squareDomNode, previousActiveSquare;
      if (!$(event.target).hasClass('grid-square')) {
        $squareDomNode = $(event.target).parents('.grid-square');
      } else {
        $squareDomNode = $(event.target);
      }
      previousActiveSquare = _this.activeSquare;
      _this.activeSquare = _this.squares[$squareDomNode.data('col')][$squareDomNode.data('row')];
      if (_this.isMoving && previousActiveSquare !== _this.activeSquare) {
        return _this.drawArrow(_this.moveStartSquare, _this.activeSquare);
      }
    });
  }

  Board.prototype.drawArrow = function(startSquare, endSquare) {
    var $squareDomNode, dx, dy, end, graph, lastDirection, lastNode, nextDirection, node, result, squareTraversalCosts, start, totalCost, _i, _j, _len, _len1;
    squareTraversalCosts = this.getSquareTraversalCosts(startSquare.col, startSquare.row, this.maxDepth);
    graph = new astar.Graph(squareTraversalCosts);
    start = graph.nodes[this.maxDepth][this.maxDepth];
    end = graph.nodes[(endSquare.col - startSquare.col) + this.maxDepth][(endSquare.row - startSquare.row) + this.maxDepth];
    result = astar.astar.search(graph.nodes, start, end);
    $('.arrow.unit-' + startSquare.units[0].id).remove();
    if (result[0].x === this.maxDepth) {
      if (result[0].y > this.maxDepth) {
        nextDirection = 'south';
      }
      if (result[0].y < this.maxDepth) {
        nextDirection = 'north';
      }
    }
    if (result[0].y === this.maxDepth) {
      if (result[0].x > 0) {
        nextDirection = 'west';
      }
      if (result[0].x < 0) {
        nextDirection = 'east';
      }
    }
    lastDirection = 'start';
    lastNode = {
      x: this.maxDepth,
      y: this.maxDepth
    };
    totalCost = 0;
    for (_i = 0, _len = result.length; _i < _len; _i++) {
      node = result[_i];
      if (node.cost === 0) {
        return;
      }
      totalCost += node.cost;
      if (totalCost > this.maxDepth) {
        return;
      }
    }
    for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
      node = result[_j];
      dx = node.x - lastNode.x;
      dy = node.y - lastNode.y;
      if (node.x === lastNode.x) {
        if (dy > 0) {
          nextDirection = 'south';
        }
        if (dy < 0) {
          nextDirection = 'north';
        }
      }
      if (node.y === lastNode.y) {
        if (dx > 0) {
          nextDirection = 'east';
        }
        if (dx < 0) {
          nextDirection = 'west';
        }
      }
      $squareDomNode = this.squares[startSquare.col + (lastNode.x - this.maxDepth)][startSquare.row + (lastNode.y - this.maxDepth)].$domNode;
      $squareDomNode.prepend($('<div class="arrow ' + lastDirection + '-' + nextDirection + ' unit-' + startSquare.units[0].id + '"></div>'));
      lastNode = node;
      if (nextDirection === 'north') {
        lastDirection = 'south';
      }
      if (nextDirection === 'south') {
        lastDirection = 'north';
      }
      if (nextDirection === 'east') {
        lastDirection = 'west';
      }
      if (nextDirection === 'west') {
        lastDirection = 'east';
      }
    }
    $squareDomNode = this.squares[startSquare.col + (lastNode.x - this.maxDepth)][startSquare.row + (lastNode.y - this.maxDepth)].$domNode;
    $squareDomNode.prepend($('<div class="arrow ' + lastDirection + '-end unit-' + startSquare.units[0].id + '"></div>'));
    return console.log('done');
  };

  Board.prototype.getSquareTraversalCosts = function(x, y, radius) {
    var col, row, squareTraversalCosts, traversalRow, _i, _j, _ref, _ref1, _ref2, _ref3;
    squareTraversalCosts = [];
    for (col = _i = _ref = x - radius, _ref1 = x + radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; col = _ref <= _ref1 ? ++_i : --_i) {
      traversalRow = [];
      for (row = _j = _ref2 = y - radius, _ref3 = y + radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; row = _ref2 <= _ref3 ? ++_j : --_j) {
        traversalRow.push(this.squares[col][row].traversalCost);
      }
      squareTraversalCosts.push(traversalRow);
    }
    return squareTraversalCosts;
  };

  return Board;

})();
