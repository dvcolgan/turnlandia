// Generated by CoffeeScript 1.6.3
var GAME, GRID_SIZE, SECTOR_SIZE, getColRowFromHash, getCoordsHalfOffset, getViewHeight, getViewWidth, getXYFromColRow, randomChoice;

GRID_SIZE = 48;

SECTOR_SIZE = 10;

randomChoice = function(collection) {
  return collection[Math.floor(Math.random() * collection.length)];
};

getViewWidth = function() {
  return Math.floor(($(window).width() - (48 + 20)) / GRID_SIZE);
};

getViewHeight = function() {
  return Math.floor(($(window).height() - 96) / GRID_SIZE);
};

getCoordsHalfOffset = function(position, length) {
  var _i, _ref, _ref1, _results;
  return (function() {
    _results = [];
    for (var _i = _ref = Math.ceil(-length / 2) + position, _ref1 = Math.ceil(length / 2) + position; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
};

getColRowFromHash = function() {
  var pieces, pos;
  pieces = window.location.hash.split('/');
  if (pieces.length < 3) {
    window.location.hash = '#/0/0/';
    pieces = window.location.hash.split('/');
  }
  pos = {
    col: parseInt(pieces[1]),
    row: parseInt(pieces[2])
  };
  return pos;
};

getXYFromColRow = function(pos) {
  return {
    x: pos.col * GRID_SIZE,
    y: pos.row * GRID_SIZE
  };
};

GAME = {
  world_names: ['Atlantis', 'Azeroth', 'Camelot', 'Narnia', 'Hyrule', 'Middle-earth', 'The Neverhood', 'Rapture', 'Terabithia', 'Kanto', 'The Grand Line', 'Tatooine', 'Naboo', 'Pandora', 'Corneria', 'Termina', 'Xen', 'City 17', 'Tokyo', 'Ithica', 'Peru'],
  player_names: [['Frodo Baggins', 'Shire Hobbits'], ['Elrond', 'Mirkwood Elves'], ['Durin Darkhammer', 'Moria Dwarves'], ['Ness', 'Eagleland'], ['Daphnes Nohansen Hyrule', 'Hylians'], ['Aragorn son of Arathorn', 'Gondorians'], ['Strong Bad', 'Strongbadia'], ['Captain Homestar', 'The Team'], ['T-Rex', 'Dinosaurs'], ['Refrigerator', 'Kitchen Appliances'], ['The Burger King', 'Fast Foodies'], ['Larry King Live', 'Interviewees'], ['King', 'Mimigas'], ['Luke Skywalker', 'The Rebel Alliance'], ['Darth Vader', 'The Empire'], ['Jean-Luc Picard', 'The Enterprise'], ['The Borg Queen', 'The Borg'], ['Bowser', 'Koopas']],
  home: function() {},
  create_accout: function() {},
  messages: function() {},
  settings: function() {
    var settingsViewModel, startingColor;
    settingsViewModel = function() {
      var vm;
      vm = this;
      vm.leaderName = ko.observable($('#id_leader_name').val());
      vm.peopleName = ko.observable($('#id_people_name').val());
      return null;
    };
    ko.applyBindings(new settingsViewModel);
    startingColor = $('#id_color').val() || '#ffffff';
    $('#id_color').css('background-color', startingColor).css('color', startingColor);
    return $('#id_color').ColorPicker({
      color: startingColor,
      onShow: function(colpkr) {
        $(colpkr).fadeIn(100);
        return false;
      },
      onChange: function(hsb, hex, rgb) {
        return $('#id_color').val('#' + hex).css('background-color', '#' + hex).css('color', '#' + hex);
      },
      onHide: function(colpkr) {
        $(colpkr).fadeOut(100);
        return false;
      }
    });
  },
  game: function() {
    var dragging, gameViewModel, lastMouseX, lastMouseY, lastViewX, lastViewY;
    lastMouseX = 0;
    lastMouseY = 0;
    lastViewX = 0;
    lastViewY = 0;
    dragging = false;
    $('#board').width(getViewWidth() * GRID_SIZE).height(getViewHeight() * GRID_SIZE);
    gameViewModel = function() {
      var resizeBoard, sectorsLoaded, vm;
      vm = this;
      vm.accountID = window.accountID;
      vm.accountColor = window.accountColor;
      vm.players = ko.observableArray([]);
      vm.currentColor = ko.observable('blue');
      vm.totalUnits = ko.observable(0);
      vm.unitAction = ko.observable('place');
      vm.currentSquareOwner = ko.observable('');
      vm.unplacedUnits = ko.observable(0);
      vm.currentCursor = ko.computed = function() {
        switch (vm.unitAction()) {
          case 'place':
          case 'initial':
            return 'crosshair';
          case 'remove':
            return 'not-allowed';
          case 'settle':
            return 'all-scroll';
          case 'give':
            return 'e-resize';
          case 'wall':
            return 'vertical-text';
        }
      };
      vm.viewX = ko.observable(-$('#board').width() / 2);
      vm.viewY = ko.observable(-$('#board').height() / 2);
      vm.topCoords = ko.observableArray(getCoordsHalfOffset(0, getViewWidth()));
      vm.sideCoords = ko.observableArray(getCoordsHalfOffset(0, getViewHeight()));
      vm.sectors = ko.observableArray([]);
      vm.findSquare = function(col, row) {
        var sector, square, _i, _j, _len, _len1, _ref, _ref1;
        _ref = vm.sectors();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sector = _ref[_i];
          _ref1 = sector.squares;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            square = _ref1[_j];
            if (square.col === col && square.row === row) {
              return square;
            }
          }
        }
        return null;
      };
      vm.getUnitClass = function(idx, square) {
        return {
          first: idx() === 0,
          second: idx() === 1,
          third: idx() === 2,
          fourth: idx() === 3,
          one: square.resourceAmount() === 0 && square.wallHealth() === 0 && square.units().length === 1,
          two: square.resourceAmount() === 0 && square.wallHealth() === 0 && square.units().length === 2,
          three: square.resourceAmount() === 0 && square.wallHealth() === 0 && square.units().length === 3,
          four: square.resourceAmount() > 0 || square.wallHealth() > 0 || square.units().length === 4
        };
      };
      vm.handleSquareHover = function(square, event) {};
      vm.modifyUnit = function(square, event) {
        var canPlace, count, found, i, other, placement, squares, unit, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _ref3, _results, _results1;
        if (!(Math.abs(lastViewX - vm.viewX()) < 5 && Math.abs(lastViewY - vm.viewY()) < 5)) {
          return;
        }
        $.ajax('/api/square/' + square.col + '/' + square.row + '/' + vm.unitAction() + '/', {
          contentType: "application/json",
          data: ko.toJSON(square),
          type: 'POST',
          success: function(data, status) {
            if (status !== 'success') {
              return alert(JSON.stringify(data));
            }
          }
        });
        if (vm.unitAction() === 'initial') {
          placement = {
            8: [square],
            4: [vm.findSquare(square.col - 1, square.row), vm.findSquare(square.col + 1, square.row), vm.findSquare(square.col, square.row - 1), vm.findSquare(square.col, square.row + 1)],
            2: [vm.findSquare(square.col - 1, square.row - 1), vm.findSquare(square.col + 1, square.row + 1), vm.findSquare(square.col + 1, square.row - 1), vm.findSquare(square.col - 1, square.row + 1)],
            1: [vm.findSquare(square.col - 2, square.row), vm.findSquare(square.col + 2, square.row), vm.findSquare(square.col, square.row - 2), vm.findSquare(square.col, square.row + 2)]
          };
          for (count in placement) {
            squares = placement[count];
            for (_i = 0, _len = squares.length; _i < _len; _i++) {
              square = squares[_i];
              if (square) {
                if (square.owner() || square.units().length > 0) {
                  alert('Your placement is too close to another player.');
                  return;
                }
              }
            }
          }
          for (count in placement) {
            squares = placement[count];
            for (_j = 0, _len1 = squares.length; _j < _len1; _j++) {
              square = squares[_j];
              if (square) {
                square.units.push({
                  owner: vm.accountID,
                  ownerColor: vm.accountColor,
                  square: square.id,
                  amount: ko.observable(parseInt(count)),
                  last_turn_amount: 0
                });
                square.owner(vm.accountID);
                square.ownerColor(vm.accountColor);
              }
            }
          }
          vm.unplacedUnits(0);
          return vm.unitAction('place');
        } else if (vm.unitAction() === 'place') {
          if (vm.unplacedUnits() > 0) {
            canPlace = false;
            if (square.owner() === vm.accountID) {
              canPlace = true;
            } else {
              other = vm.findSquare(square.col - 1, square.row);
              if (other && other.owner() === vm.accountID) {
                canPlace = true;
              } else {
                other = vm.findSquare(square.col + 1, square.row);
                if (other && other.owner() === vm.accountID) {
                  canPlace = true;
                } else {
                  other = vm.findSquare(square.col, square.row - 1);
                  if (other && other.owner() === vm.accountID) {
                    canPlace = true;
                  } else {
                    other = vm.findSquare(square.col, square.row + 1);
                    if (other && other.owner() === vm.accountID) {
                      canPlace = true;
                    }
                  }
                }
              }
            }
            if (!canPlace) {
              alert('You can only place units on a square you own or adjacent to a square you own.');
              return;
            }
            found = false;
            _ref = square.units();
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              unit = _ref[_k];
              if (unit.owner === vm.accountID) {
                if (unit.amount() >= 20) {
                  alert('A square can only hold 20 of your units at a time.');
                  return;
                }
                unit.amount(unit.amount() + 1);
                vm.unplacedUnits(vm.unplacedUnits() - 1);
                found = true;
                break;
              }
            }
            if (!found) {
              vm.unplacedUnits(vm.unplacedUnits() - 1);
              return square.units.push({
                owner: vm.accountID,
                ownerColor: vm.accountColor,
                square: square.id,
                amount: ko.observable(1),
                last_turn_amount: 0
              });
            }
          }
        } else if (vm.unitAction() === 'remove') {
          _results = [];
          for (i = _l = 0, _ref1 = square.units().length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
            unit = square.units()[i];
            if (unit.owner === vm.accountID) {
              if (unit.amount() === 1) {
                square.units.splice(i, 1);
              } else {
                unit.amount(unit.amount() - 1);
              }
              vm.unplacedUnits(vm.unplacedUnits() + 1);
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } else if (vm.unitAction() === 'settle') {
          for (i = _m = 0, _ref2 = square.units().length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
            unit = square.units()[i];
            if (unit.owner === vm.accountID) {
              if (square.wallHealth() > 0) {
                alert('You can not settle on a square with a wall.');
                return;
              }
              if (square.owner() !== vm.accountID) {
                alert('You can not settle on a square you do not own.');
                return;
              }
              square.resourceAmount(square.resourceAmount() + 4);
              square.units()[i].amount(square.units()[i].amount() - 1);
              if (square.units()[i].amount() === 0) {
                square.units.splice(i, 1);
              }
              break;
            }
          }
        } else if (vm.unitAction() === 'wall') {
          _results1 = [];
          for (i = _n = 0, _ref3 = square.units().length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; i = 0 <= _ref3 ? ++_n : --_n) {
            unit = square.units()[i];
            if (unit.owner === vm.accountID) {
              square.wallHealth(square.wallHealth() + 2);
              square.resourceAmount(0);
              square.units()[i].amount(square.units()[i].amount() - 1);
              if (square.units()[i].amount() === 0) {
                square.units.splice(i, 1);
              }
              break;
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }
      };
      vm.loadSectorsOnScreen = function() {
        var sectorPixelSize, sectorX, sectorY, sectorsHigh, sectorsWide, x, y, _i, _results;
        sectorPixelSize = SECTOR_SIZE * GRID_SIZE;
        sectorsWide = Math.ceil(getViewWidth() / SECTOR_SIZE);
        sectorsHigh = Math.ceil(getViewHeight() / SECTOR_SIZE);
        _results = [];
        for (sectorX = _i = 0; 0 <= sectorsWide ? _i <= sectorsWide : _i >= sectorsWide; sectorX = 0 <= sectorsWide ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (sectorY = _j = 0; 0 <= sectorsHigh ? _j <= sectorsHigh : _j >= sectorsHigh; sectorY = 0 <= sectorsHigh ? ++_j : --_j) {
              x = (Math.floor(vm.viewX() / sectorPixelSize) * SECTOR_SIZE) + sectorX * SECTOR_SIZE;
              y = (Math.floor(vm.viewY() / sectorPixelSize) * SECTOR_SIZE) + sectorY * SECTOR_SIZE;
              _results1.push(vm.loadSector(x, y));
            }
            return _results1;
          })());
        }
        return _results;
      };
      sectorsLoaded = {};
      vm.loadSector = function(col, row) {
        var lookup;
        lookup = col + ' ' + row;
        if (lookup in sectorsLoaded || col > MAX_COL || col < MIN_COL || row > MAX_ROW || row < MIN_ROW) {
          return;
        } else {
          sectorsLoaded[lookup] = true;
        }
        return $.getJSON('/api/sector/' + col + '/' + row + '/' + SECTOR_SIZE + '/' + SECTOR_SIZE + '/', function(data, status) {
          var i, player, square, squares, unit, units, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
          if (status === 'success') {
            squares = [];
            _ref = data.squares;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              square = _ref[i];
              units = [];
              _ref1 = square.units;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                unit = _ref1[_j];
                units.push({
                  owner: unit.owner,
                  ownerColor: unit.owner_color,
                  square: square.id,
                  amount: ko.observable(unit.amount),
                  last_turn_amount: unit.last_turn_amount
                });
              }
              squares.push({
                left: parseInt((i % SECTOR_SIZE) * GRID_SIZE) + 'px',
                top: parseInt(Math.floor(i / SECTOR_SIZE) * GRID_SIZE) + 'px',
                units: ko.observableArray(units),
                owner: ko.observable(square.owner),
                ownerColor: ko.observable(square.owner_color),
                id: square.id,
                col: square.col,
                row: square.row,
                wallHealth: ko.observable(square.wall_health),
                resourceAmount: ko.observable(square.resource_amount)
              });
            }
            vm.sectors.push({
              col: col,
              row: row,
              squares: squares
            });
            vm.unplacedUnits(data.unplaced_units);
            _ref2 = data.players_visible;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              player = _ref2[_k];
              vm.players.push(player);
            }
            if (data.is_initial) {
              vm.unitAction('initial');
            }
            return sectorsLoaded[lookup] = true;
          } else {
            return alert(JSON.stringify(data));
          }
        });
      };
      vm.loadSectorsOnScreen();
      $('#board').mousedown(function(event) {
        event.preventDefault();
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        lastViewX = vm.viewX();
        lastViewY = vm.viewY();
        return dragging = true;
      });
      $('#board').mousemove(function(event) {
        if (dragging) {
          event.preventDefault();
          vm.viewX(lastViewX - (event.clientX - lastMouseX));
          vm.viewY(lastViewY - (event.clientY - lastMouseY));
          return vm.loadSectorsOnScreen();
        }
      });
      $(document).mouseup(function(event) {
        return dragging = false;
      });
      $(document).keydown(function(event) {
        switch (event.which) {
          case 49:
            return vm.unitAction('place');
          case 50:
            return vm.unitAction('remove');
          case 51:
            return vm.unitAction('settle');
          case 52:
            return vm.unitAction('wall');
        }
      });
      resizeBoard = function() {
        $('#board').width(getViewWidth() * GRID_SIZE).height(getViewHeight() * GRID_SIZE);
        return vm.loadSectorsOnScreen();
      };
      $(window).resize(resizeBoard);
      resizeBoard();
      return null;
    };
    return ko.applyBindings(new gameViewModel);
  }
};

$(function() {
  var cl;
  $.ajaxSetup({
    crossDomain: false,
    beforeSend: function(xhr, settings) {
      if (!/^(GET|HEAD|OPTIONS|TRACE)$/.test(settings.type)) {
        return xhr.setRequestHeader("X-CSRFToken", $.cookie('csrftoken'));
      }
    }
  });
  cl = $('body').attr('class');
  if (cl) {
    return GAME[cl]();
  }
});
